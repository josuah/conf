#!/usr/bin/awk -f

## utilities ##

function die(msg)
{
	print FILENAME ": " msg >"/dev/stderr"
	exit(1)
}

function color(n)
{
	return (ENVIRON["NCOLOR"]) ? "" : sprintf("\033[%dm", n)
}

function assert(expr, fn)
{
	if (!expr)
		die(fn ": assert failed")
}

function array_join(array, sep,
	i, str)
{
	for (i = 1; i in array; i++)
		str = (i == 1 ? array[i] : str sep array[i])
	return str
}

function array_swap(array, a, b,
	tmp)
{
	tmp = array[a]
	array[a] = array[b]
	array[b] = tmp
}

function array_keys(array, keys,
	n, x)
{
	split("", keys)
	for (x in array)
		keys[++n] = x
	array_sort(keys, 1, n)
	return n
}

function array_sort(array, beg, end)
{
	if (beg >= end)					# end recursion
		return

	a = beg + 1					# 1st is the pivot
	b = end
	while (a < b) {
		while (a < b && array[a] <= array[beg])	# beg: skip lesser
			a++
		while (a < b && array[b] > array[beg])	# end: skip greater
			b--
		array_swap(array, a, b)			# found 2 misplaced
	}

	if (array[beg] > array[a])			# put the pivot back
		array_swap(array, beg, a)

	array_sort(array, beg, a - 1)			# sort top half
	array_sort(array, a, end)			# sort bottom half
}

function array_prefix_keys(array_in, array_out, prefix,
	x)
{
	for (x in array_in) {
		array_out[prefix x] = array_in[x]
		delete array_out[x]
	}
}

function array_shift(array,
	first, i)
{
	assert(1 in array)
	first = array[1]
	for (i = 1; i + 1 in array; i++)
		array[i] = array[i + 1]
	delete array[i]
	return first
}

function array_delete(array, prefix,
	x)
{
	for (x in array)
		if (substr(array[x], 1, length(prefix)) == prefix)
			delete array[x]
}

## database ##

function db_cache_glob(path,
	glob, array, n, line, head, tail)
{
	"echo " file["path"] | getline glob
	close("echo " file["path"])

	if (index(glob, "*"))
		return 0

	head = index(path, "*")
	assert(head > 0)
	tail = length(path) - head - 1

	FILECACHE["path"] = split(glob, array, " ")
	while (n in array) {
		item = substr(array[n], head, length(array[n] - head - tail))
		FILECACHE[file["path"] ":" n] = "path=" db_format_val(item)
	}
	return FILECACHE["path"]
}

function db_cache_file(path,
	line, n)
{
	while ((getline line <path) > 0) {
		if (line ~ /^[ \t]*#/)
			continue
		FILECACHE[path ":" ++n] = line
	}
	close(path)
	return FILECACHE[path] = n
}

function db_cache_path(path)
{
	if (path in FILECACHE)
		return FILECACHE[path]
	return index(path, "*") ? db_cache_glob(path) : db_cache_file(path)
}

function db_get_line(file)
{
	if (file["#"] >= db_cache_path(file["path"]))
		return 0
	file["#"]++
	assert(file["path"] ":" file["#"] in FILECACHE)
	file["line"] = FILECACHE[file["path"] ":" file["#"]]
	return file["#"]
}

function db_split(str, argv)
{
	# escape special characters
	gsub(/\t/, " ", str)
	gsub(/\\\\/, "\\s", str)
	gsub(/\\"/, "\\q", str)

        # match key or key=value or key="value value"
        gsub(/[^= \t]+(="[^"]*"|=[^" \t]*)?/, "\t&\t", str)

	# cleanup
        gsub(/[ \t]*\t[ \t]*/, "\t", str)
	sub("^[ \t]*", "", str)
	sub("[ \t]*$", "", str)

	# split ito argv
	split(str, argv, "\t")

	# restore escaped inline characters
	for (x in argv) {
		gsub(/"/, "", argv[x])
		gsub(/\\q/, "\"", argv[x])
		gsub(/\\s/, "\\", argv[x])
	}
}

function db_key_value(argv, row, keys,
	i, n, key, eq, val)
{
	for (i = 1; i in argv; i++) {
		eq = index(argv[i], "=")
		if (eq == 0) {
			keys[++n] = argv[i]
		} else {
			key = substr(argv[i], 1, eq - 1)
			val = substr(argv[i], eq + 1)
			row[key] = val
		}
	}
}

function db_get_row(file, row,
	argv, line, n)
{
	if (db_get_line(file) == 0)
		return 0
	db_split(file["line"], argv)
	split("", row)
	db_key_value(argv, row)
	return 1
}

function db_match(query, row,
	x)
{
	for (x in query)
		if (!(x in row) || row[x] != query[x])
			return 0
	return 1
}

function db_get_match(file, query, row)
{
	while (db_get_row(file, row))
		if (db_match(query, row))
			return 1
	return 0
}

function db_query(file, keys, query, result,
	row, found, i, n)
{
	while (db_get_match(file, query, row)) {
		n = 0
		split("", result)
		for (i = 1; i in keys; i++) {
			if (keys[i] in row)
				found = 1
			result[++n] = row[keys[i]]
		}
		if (found)
			return 1
	}
	return 0
}

function db_format_val(val)
{
	gsub("\t", " ", val)
	gsub("\\", "\\s", val)
	gsub("\"", "\\q", val)
	return index(val, " ") ? "\"" val "\"" : val
}

function db_format_row(row,
	i, keys, sp, out)
{
	if (array_keys(row, keys) == 0)
		return
	for (i = 1; i in keys; i++) {
		if (keys[i] == "#")
			continue
		out = out sp keys[i] "=" db_format_val(row[keys[i]])
		sp = " "
	}
	return out
}

function db_print_pretty(ln, row, width,
	i, n, put, len, col, keys, val)
{
	printf("%3d ", ln)
	col = 4

	n = array_keys(row, keys)
	for (i = 1; i <= n; i++) {
		len = 1 + length(keys[i]) + 1 + length(row[keys[i]])
		if (col + len > width && col > 4) {
			printf "\n    "
			col = 4
		}
		val = db_format_val(row[keys[i]])
		printf " " color(36) "%s=" color(0) "%s", keys[i], val
		col += len
	}

	printf "\n"
}

function db_print_tree(path, lv,
	node)
{
	while (db_get_row(file, row)) {
		if ("add" in row) {
			printf "%" (lv*2) "s%s ", "", row["add"]
			node = row["add"]
			delete row["add"]
			print db_format_row(row)
			db_print_tree(node "/db", lv + 1)
		}
	}
}

function db_expand(str,
	x)
{
	for (x in ENVIRON)
		gsub("\\[" x "\\]", ENVIRON[x], str)
	return str
}

## templates ##

function tpl_replace(text,
	head, tail, str, result, value)
{
	tail = text
	while (match(tail, "\\{\\{[^}]+\\}\\}")) {
		str = substr(tail, RSTART + 2, RLENGTH - 4)
		sub("^ *", "", str)
		sub(" *$", "", str)
		str = db_expand(str)

		if (str in ENVIRON) {
			value = ENVIRON[str]
		} else if (tpl_query(str, result)) {
			value = result[1]
		} else {
			die("no result for " str)
		}

		head = head substr(tail, 1, RSTART - 1) value
		tail = substr(tail, RSTART + RLENGTH)
	}
	return head tail
}

function tpl_inc_tail(lv,
	n, array)
{
	n = split(lv, array, ".")
	array[n]++
	return array_join(array, ".")
}

function tpl_inc_level(lv,
	n, array)
{
	n = split(lv, array, ".")
	array[n + 1] = 1
	return array_join(array, ".")
}

function tpl_dec_level(lv,
	n, array)
{
	n = split(lv, array, ".")
	delete array[n]
	return array_join(array, ".")
}

function tpl_get_match(str, pos, n, row,
	i, file, glob, argv, query)
{
	db_split(str, argv)
	file["path"] = array_shift(argv)
	file["#"] = pos[n]

	db_key_value(argv, query)
	if (db_get_match(file, query, row) == 0)
		return 0

	pos[n] = file["#"]
	return 1
}
 
function tpl_query(str, result,
	file, keys, query, argv, e)
{
	if (sub(":", " ", str) == 0)
		die("unrecognized parameter: " str)
	db_split(str, argv)
	file["path"] = array_shift(argv)
	db_key_value(argv, query, keys)
	e = db_query(file, keys, query, result)
	close(file["path"])
	return e
}

function tpl_flush(texts, queries, lv,
	n, x, _, row)
{
	if (!(lv in texts))
		return

	n = split(lv, _, ".")
	while (tpl_get_match(db_expand(queries[lv]), pos, n, row)) {
		array_prefix_keys(row, ENVIRON, n ":")
		for (x = lv; x in texts; x = tpl_inc_tail(x)) {
			printf "%s", tpl_replace(texts[x])
			tpl_flush(texts, queries, tpl_inc_level(x))
		}
	}
	array_delete(ENVIRON, n ":")
}

function tpl_add_line(texts, lv, line)
{
	if (lv == "") {
		print tpl_replace(line)
	} else {
		texts[lv] = texts[lv] line "\n"
	}
}

## commands ##

function cmd_template(file, argv,
	line, include, lv, queries, texts)
{
	if (1 in argv)
		usage()

	ENVIRON["path"] = file["path"]

	while ((getline line <file["path"]) > 0) {

		if (sub(/^#+include /, "", line)) {
			include = db_expand(line)
			while ((getline line <include) > 0)
				tpl_add_line(texts, lv, line)

		} else if (sub(/^#+for /, "", line)) {
			lv = tpl_inc_level(lv)
			queries[lv] = line
			texts[lv] = ""  # lv in texts

		} else if (line ~ /^#+end/) {
			if (lv == "")
				die("more #end than #for")
			lv = tpl_dec_level(lv)
			lv = tpl_inc_tail(lv)
			texts[lv] = ""  # lv in texts

			if (lv == "") {
				tpl_flush(texts, queries, "1")
				split("", texts)
				split("", queries)
			}

		} else {
			tpl_add_line(texts, lv, line)
		}
	}
	close(file["path"])
}

function cmd_get(file, argv,
	keys, query, result, i, n)
{
	if (!(1 in argv))
		usage()

	db_key_value(argv, query, keys)
	while (db_query(file, keys, query, result)) {
		for (i = 1; i in result; i++)
			printf "%s%s", (i == 1 ? "" : "\t"), result[i]
		printf "\n"
	}
}

function cmd_list(file, argv,
	cmd, query, row, width)
{
	cmd = "stty size 2>/dev/null"
	cmd | getline width
	close(cmd)

	sub(".* ", "", width)
	width = (width == "" ? 80 : width + 0)

	printf "\n"
	db_key_value(argv, query)
	while (db_get_match(file, query, row)) {
		db_print_pretty(file["#"], row, width)
		printf "\n"
	}
}

function cmd_tree(file, argv)
{
	if (1 in argv)
		usage()

	db_print_tree(file["path"], 0)
}

function cmd_add(file, argv,
	row)
{
	if (!(1 in argv))
		usage()

	db_key_value(argv, row)
	print db_format_row(row) >>file["path"]
}

function cmd_del(file, argv,
	x, num, array)
{
	if (!(1 in argv) || (2 in argv))
		usage()

	split(argv[1], array, ",")
	for (x in array)
		num[array[x]]++

	"mktemp" | getline tmp
	close("mktemp")

	while (db_get_row(file, row)) {
		if (file["#"] in num)
			continue
		print db_format_row(row) >>tmp
	}
	return system("mv -f '" tmp "' '" file["path"] "'") == 0
}

function cmd_set(path, argv,
	x, array, num, row, tmp)
{
	if (!(2 in argv))
		usage()

	split(array_shift(argv), array, ",")
	for (x in array)
		num[array[x]]++

	"mktemp" | getline tmp
	close(mktemp)

	while (db_get_row(file, row)) {
		if (file["#"] in num) {
			split("", keys)
			db_key_value(argv, row, keys)
			for (x in keys)
				delete row[keys[x]]
		}
		print db_format_row(row) >>tmp
	}
	return system("mv -f '" tmp "' '" path "'") == 0
}

function cmd_num(path, argv,
	query, row, first)
{
	db_key_value(argv, query)
	for (first = 1; db_get_match(file, query, row); first = 0)
		printf "%s%s", (first ? "" : ","), file["#"]
	printf "\n"
}

function cmd_move(path, argv,
	x, array, num, to, row, tmp, block)
{
	if (!(2 in argv) || (3 in argv))
		usage()

	split(array_shift(argv), array, ",")
	for (x in array)
		num[array[x]] = x

	to = array_shift(argv)

	while (db_get_row(file, row))
		if (file["#"] in num)
			block = block db_format_row(row)
	if (to < 1 || to > file["#"])
		die("destination outside possible values: " to)

	"mktemp" | getline tmp
	close("mktemp")

	delete file["#"]
	while (db_get_row(file, row)) {
		if (file["#"] == to)
			print block >>tmp
		if (!(file["#"] in num))
			print db_format_row(row) >>tmp
	}

	system("mv '" tmp "' '" path "'")
}

## main ##

function usage()
{
	print "usage:"						>"/dev/stderr"
	print " adm-db <db> add <key>=<value>..."		>"/dev/stderr"
	print " adm-db <db> del <n>"				>"/dev/stderr"
	print " adm-db <db> get <key> [<key>=<value>...]"	>"/dev/stderr"
	print " adm-db <db> list [<key>=<value>...]"		>"/dev/stderr"
	print " adm-db <db> move <n> <n>"			>"/dev/stderr"
	print " adm-db <db> num <key>=<value>..."		>"/dev/stderr"
	print " adm-db <db> set <n> <key>=<value>..."		>"/dev/stderr"
	print " adm-db <db> tree"				>"/dev/stderr"
	print " adm-db <template> template"			>"/dev/stderr"
	exit(1)
}

BEGIN {
	cmd = "date +%s"
	cmd | getline ENVIRON["now"]
	close(cmd)

	if (!(2 in ARGV))
		usage()

	FILENAME = file["path"] = array_shift(ARGV)
	cmd = array_shift(ARGV)

	if (cmd == "add") { cmd_add(file, ARGV) } else
	if (cmd == "del") { cmd_del(file, ARGV) } else
	if (cmd == "get") { cmd_get(file, ARGV) } else
	if (cmd == "list") { cmd_list(file, ARGV) } else
	if (cmd == "move") { cmd_move(file, ARGV) } else
	if (cmd == "num") { cmd_num(file, ARGV) } else
	if (cmd == "set") { cmd_set(file, ARGV) } else
	if (cmd == "template") { cmd_template(file, ARGV) } else
	if (cmd == "tree") { cmd_tree(file, ARGV) } else
		usage()
}
