#!/usr/bin/awk -f

function usage()
{
	print "usage:"					>"/dev/stderr"
	print " adm-db list <path> [<query>]"		>"/dev/stderr"
	print " adm-db get <query>"			>"/dev/stderr"
	print " adm-db set <n>,... <key>=<value>..."	>"/dev/stderr"
	print " adm-db new <n> <key>=<value>..."	>"/dev/stderr"
	print " adm-db add <key>=<value>..."		>"/dev/stderr"
	print " adm-db move <n1> <n2>"			>"/dev/stderr"
	print " adm-db template <file.template>"	>"/dev/stderr"
	exit(1)
}


## util ##

function die(msg)
{
	print "error: " msg >"/dev/stderr"
	exit(1)
}

function join(table, sep,
	i, str)
{
	for (i = 1; i in table; i++)
		str = (i == 1) ? (table[i]) : (str sep table[i])
	return str
}

function swap(table, a, b,
	tmp)
{
	tmp = table[a]
	table[a] = table[b]
	table[b] = tmp
}

function qsort(table, beg, end)
{
	if (beg >= end)					# end recursion
		return

	a = beg + 1					# 1st is the pivot
	b = end
	while (a < b) {
		while (a < b && table[a] <= table[beg])	# beg: skip lesser
			a++
		while (a < b && table[b] > table[beg])	# end: skip greater
			b--
		swap(table, a, b)			# found 2 misplaced
	}

	if (table[beg] > table[a])			# put the pivot back
		swap(table, beg, a)

	qsort(table, beg, a - 1)			# sort top half
	qsort(table, a, end)				# sort bottom half
}

function table_delete(table, pfx,
	i)
{
	for (i in table)
		if (substr(i, 1, length(prefix)) == prefix)
			delete table[i]
}

function table_copy(dst, src,
	x)
{
	for (x in src)
		dst[x] = src[x]
}

function color(n)
{
	return (ENVIRON["NCOLOR"]) ? "" : sprintf("\033[%dm", n)
}


## db ##

function db_clean(line)
{
	gsub("[ \t]+", " ", line)
	sub("^ *", "", line)
	sub(" *$", "", line)
	return line
}

function db_split(line, row, prefix,
	table, i, eq, key, val)
{
	split(db_clean(line), table, " ")
	for (i in table) {
		eq = index(table[i], "=")
		if (eq == 0) {
			row[prefix table[i]] = 1
		} else {
			key = substr(table[i], 1, eq - 1)
			val = substr(table[i], eq + 1)
			row[prefix key] = val
		}
	}
}

function db_getline(path, prefix, row,
	table, line, n)
{
	if ((getline line <path) <= 0) {
		close(path)
		return 0
	}
	if (line ~ /^[ \t]*#/)
		return db_getline(path, prefix, row)

	n = row[""]
	db_split(line, row, prefix)
	row[""] = n + 1
	return 1
}

function db_match(line, row, prefix,
	query, x, key)
{
	db_split(line, query)
	for (key in query)
		if (!(prefix key in row) || query[key] != row[prefix key])
			return 0
	return 1
}

function db_getmatch(path, line, prefix, row)
{
	while (db_getline(path, prefix, row))
		if (db_match(line, row, prefix))
			return 1
	return 0
}

function db_expand(str, vars,
	i)
{
	for (i in vars)
		gsub("\\[" i "\\]", vars[i], str)
	return str
}

function db_query(line, prefix, row,
	sp, col, path, ret)
{
	sp = index(line, " ")
	if (sp) {
		path = substr(line, 1, sp - 1)
		line = substr(line, sp + 1)
		sub(/:.*/, "", path)
		return db_getmatch(path, line, prefix, row)
	} else {
		path = line
		sub(/:.*/, "", path)
		return db_getline(path, prefix, row)
	}
}

function db_search(line, prefix, result,
	n, key, row)
{
	key = line
	sub(/ .*/, "", key)
	if (sub(/.*:/, "", key) == 0)
		die("missing :key selector in " line)

	split("", result)
	while (db_query(line, prefix, row))
		if (key in row)
			result[++n] = row[key]
	return n
}

function db_pprint(row, width,
	i, n, put, len, col, keys)
{
	for (i in row)
		keys[++n] = i

	qsort(keys, 1, n)

	printf("%3d ", row[""])
	col = 4

	for (i = 2; i <= n; i++) {
		len = 1 + length(keys[i]) + 1 + length(row[keys[i]])
		if (col + len > width && i < n) {
			printf "\n    "
			col = 4
		}
		printf " " color(36) "%s=" color(0) "%s", keys[i], row[keys[i]]
		col += len
	}
	printf "\n"
}


## tpl ##

function tpl_replace(text, vars,
	head, tail, line, result, value, n)
{
	tail = text
	while (match(tail, "\\{\\{[^}]+\\}\\}")) {
		line = substr(tail, RSTART + 2, RLENGTH - 4)
		sub("^ *", "", line)
		sub(" *$", "", line)
		line = db_expand(line, vars)

		if (line in G) {
			value = VAR[line]
		} else if (line in vars) {
			value = vars[line]
		} else {
			n = db_search(line, result, prefix)

			if (n == 0)
				die("no result for " line)
			for (n in result)
				break
			value = result[n]
		}

		head = head substr(tail, 1, RSTART - 1) value
		tail = substr(tail, RSTART + RLENGTH)
	}
	return head tail
}

function tpl_inc_tail(lv,
	n, table)
{
	n = split(lv, table, ".")
	table[n]++
	return join(table, ".")
}

function tpl_inc_level(lv,
	n, table)
{
	n = split(lv, table, ".")
	table[n + 1] = 1
	return join(table, ".")
}

function tpl_dec_level(lv,
	n, table)
{
	n = split(lv, table, ".")
	delete table[n]
	return join(table, ".")
}

function tpl_flush(texts, queries, lv, vars,
	n, x, table)
{
	if (!(lv in texts))
		return

	n = split(lv, table, ".")
	while (db_query(db_expand(queries[n], vars), n ":", table)) {
		table_copy(vars, table)
		for (x = lv; x in texts; x = tpl_inc_tail(x)) {
			printf "%s", tpl_replace(texts[x], vars)
			tpl_flush(texts, queries, tpl_inc_level(x), vars)
		}
	}
	table_delete(vars, n ":")
}


## cmd ##

function cmd_template(argv,
	path, line, lv, queries, texts)
{
	if (!(2 in argv) || (3 in argv))
		usage()

	VAR["path"] = path = argv[2]

	while (getline line <path) {

		if (sub(/^#+for /, "", line)) {
			lv = tpl_inc_level(lv)
			queries[split(lv, table, ".")] = line

		} else if (line ~ /^#+end/) {
			if (lv == "")
				die("more #end than #for")
			lv = tpl_dec_level(lv)
			lv = tpl_inc_tail(lv)

			if (lv == "") {
				tpl_flush(texts, queries, "1")
				table_delete(queries)
				table_delete(texts)
			}

		} else if (lv == "") {
			print tpl_replace(line)

		} else {
			texts[lv] = texts[lv] line "\n"
		}
	}
}

function cmd_get(argv,
	query, result, i, n)
{
	for (i = 2; i in argv; i++)
		query = query " " argv[i]

	query = db_clean(query)
	n = db_search(query, "", result)

	for (i = 1; i <= n; i++)
		if (i in result)
			print result[i]
}

function cmd_list(argv,
	cmd, path, sp, line, row, width)
{
	if (system("ls '" argv[2] "/' 2>/dev/null") == 0)
		return 0

	cmd = "stty size 2>/dev/null"
	cmd | getline width
	close(cmd)
	sub(".* ", "", width)
	width = (width == "" ? 80 : width + 0)

	for (i = 2; i in argv; i++)
		line = line " " argv[i]

	line = db_clean(line)
	sp = index(line, " ")
	if (sp) {
		path = substr(line, 1, sp - 1)
		line = substr(line, sp + 1)
	} else {
		path = line
		line = ""
	}
	sub(":.*", "", path)

	while (db_getmatch(path, line, "", row))
		db_pprint(row, width)
}


## main ##

BEGIN {
	cmd = "date +%s"
	cmd | getline VAR["now"]
	close(cmd)

	cmd = "hostname -s"
	cmd | getline VAR["host"]
	close(cmd)

	if (ARGV[1] == "get") {
		cmd_get(ARGV)

	} else if (ARGV[1] == "list") {
		cmd_list(ARGV)

	} else if (ARGV[1] == "template") {
		cmd_template(ARGV)

	} else {
		usage()
	}
}
