#!/usr/bin/awk -f

# Example of #macros and {{ variables }}:
#
#	line printed directly
#
#	#for dir
#
#	x = {{ static/variable }}
#	lines added to blk_texts["1"]
#
#	##for dir/%1/subdir
#	y = {{ dir/%1/subdir/%2/name }}
#	lines added to blk_texts["1.1"]
#	##end
#
#	z = {{ still/%1/there }}
#	line added to blk_texts["2"]
#
#	##for dir/%1/subdir
#	t = {{ dir/%1/subdir/%2/type }}
#	lines added to blk_texts["2.1"]
#	##end
#
#	lines added to blk_texts["3"]
#	
#	#end
#
#	line printed directly

function die(msg)
{
	print "error: " msg >"/dev/stderr"
	exit(1)
}

function join(array, sep,
	i, str)
{
	for (i = 1; i in array; i++)
		str = (i == 1) ? (array[i]) : (str sep array[i])
	return str
}

function replace_key(key, items,
	i, n)
{
	for (i in items)
		n++
	for (i = n; i > 0; i--) {
		gsub("%"i, items[i], key)
		blk = blk_dec_level(blk)
	}

	gsub("@", HOSTNAME, key)

	return key
}

function replace_text(texts, items,
	head, tail, key, value)
{
	tail = texts
	while (match(tail, "\\{\\{[^}]+\\}\\}")) {
		key = substr(tail, RSTART + 2, RLENGTH - 4)
		sub("^ *", "", key)
		sub(" *$", "", key)

		if (key ~ /^[0-9]+$/) {
			value = items[key]
		} else if (key == "path") {
			value = FILENAME
		} else if (key == "now") {
			value = NOW
		} else {
			key = replace_key(key, items)
			if ((getline value <key) <= 0)
				die("cannot read " key " or file empty")
		}

		head = head substr(tail, 1, RSTART - 1) value
		tail = substr(tail, RSTART + RLENGTH)
	}
	return head tail
}

function blk_print(texts, items)
{
	printf "%s", replace_text(texts[blk], items)
}

function blk_inc_tail(blk,
	n, array)
{
	n = split(blk, array, ".")
	array[n]++
	return join(array, ".")
}

function blk_inc_level(blk,
	n, array)
{
	n = split(blk, array, ".")
	array[n + 1] = 1
	return join(array, ".")
}

function blk_dec_level(blk,
	n, array)
{
	n = split(blk, array, ".")
	delete array[n]
	return join(array, ".")
}

function blk_get_next(map, blk,
	str)
{
	str = blk_inc_level(blk)
	if (str in map)
		return str

	str = blk_dec_level(blk)
	str = blk_inc_tail(str)
	if (str in map)
		return str

	return ""
}

function shell_escape(str)
{
	gsub("'", "'\\''", str);
	return "'" str "'"
}

function blk_iterate(blk, texts, paths, items,
	this, cmd, line, array)
{
	this = replace_key(paths[blk], items)

	if (system("test -d " shell_escape(this)) == 0) {
		cmd = "ls " shell_escape(this);
		if ((cmd | getline line) <= 0) {
			close(cmd)
			return 0
		}
	} else {
		if ((getline line <this) <= 0) {
			close(this)
			return 0
		}
	}
	items[split(blk, array, ".")] = line
	return 1
}

function blk_flush(texts, paths, items, blk,
	array, n)
{
	blk = blk_inc_level(blk)
	if (!(blk in texts))
		return

	while (blk_iterate(blk, texts, paths, items)) {
		printf "%s", replace_text(texts[blk], items)
		blk_flush(texts, paths, items, blk)
	}
	n = split(blk, array, ".")
	delete items[n]
	delete paths[n]
	delete texts[blk]
}

BEGIN {
	cmd = "date +'%Y/%m/%d %H:%M:%S %z'"
	cmd | getline NOW
	close(cmd)

	cmd = "hostname -s"
	cmd | getline HOSTNAME
	close(cmd)

	EMPTY["none"] = 0
	delete EMPTY["none"]
}

/^#+for / {
	blk = blk_inc_level(blk)
	blk_paths[blk] = $2
	blk_dirty = 1
	next
}

/^#+end/ {
	if (blk == "")
		die("more #end than #for")
	blk = blk_dec_level(blk)

	if (blk == "")
		blk_flush(blk_texts, blk_paths, blk_items, "")
	next
}

blk != "" {
	blk_texts[blk] = blk_texts[blk] $0 "\n"
}

blk == "" {
		print replace_text($0)
}
