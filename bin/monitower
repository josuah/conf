#!/usr/bin/awk -f
# read/write to a ring-buffer time series database of up/down events

function die(message)
{
	print "error: "message >"/dev/stderr"
	exit(1)
}

function assert(expr, fn)
{
	if (!expr)
		die("assertion failed at "fn"()")
}

function max(a, b)
{
	return a > b ? a : b
}

function min(a, b)
{
	return a < b ? a : b
}

function now(time)
{
	"exec date +%s" | getline time
	close("exec date +%s")
	return time
}

function db_open(db, path,
	cmd, a)
{
	if (index(path, "'") != 0)
		die("path: single quote char")
	if ("size" in db)
		return
	if ((getline <path) <= 0)
		die("error reading database header for "path)
	split($0, a, " ")
	db["time"] = int(a[1])
	db["step"] = int(a[2])
	db["size"] = int(a[3])
	db["skip"] = length($0) + 1
	db["end"] = int(db["time"] / db["step"])
	db["beg"] = db["end"] - db["size"]
	db["path"] = path
}

function db_close(db,
	path)
{
	if (!("path" in db))
		return
	path = db["path"]
	split("", db)
	close(db["path"] = path)
}

function db_init(path, step, size,
	i, time)
{
	if (index(path, "'") != 0)
		die("single quote in path '"path"'")

	time = 0
	printf "%015d %015d %015d\n", time, step, size >path
	for (i = 0; i < size; i++)
		printf "0" >>path
	printf "\n" >>path
	close(path)
}

function db_time(db, time,
	cmd)
{
	db["time"] = time
	cmd = "exec dd of='"db["path"]"' conv=notrunc bs=15 count=1 2>/dev/null"
	printf "%015d", time | cmd
	close(cmd)
}

function db_read(db, pos, len,
	val)
{
	skip = db["skip"] + pos
	cmd = "exec dd if='"db["path"]"' bs=1 skip="skip" count="len" 2>/dev/null"
	cmd | getline val
	close(cmd)
	return val
}

function db_write(db, val, pos, len)
{
	seek = db["skip"] + pos
	cmd = "exec dd of='"db["path"]"' conv=notrunc bs=1 seek="seek" 2>/dev/null"
	while (len-- > 0)
		printf "%s", val | cmd
	close(cmd)
}

function db_get(db, beg, end,
	i, head, tail)
{
	assert(beg <= end, "db_get")

	for (i = min(db["beg"], end); i > beg; i--)
		head = head "0"
	for (i = max(db["end"], beg); i < end; i++)
		tail = tail "0"

	if (beg > db["end"] || end < db["beg"])
		return head tail

	beg = max(db["beg"], beg) % db["size"]
	end = min(db["end"], end) % db["size"]

	return (beg <= end) \
	 ? head db_read(db, beg, end - beg) tail \
	 : head db_read(db, beg, db["size"] - beg) db_read(db, 0, end) tail
}

function db_set(db, val, beg, end,
	len)
{
	assert(beg <= end, "db_set")

	len = end - beg
	beg = beg % db["size"]
	end = end % db["size"]

	if (len > db["size"]) {
		db_write(db, val, 0, db["size"])
	} else if (beg < end) {
		db_write(db, val, beg, end - beg)
	} else if (end < beg) {
		db_write(db, val, beg, db["size"] - beg)
		db_write(db, val, 0, end)
	}
}

function db_add(db, val,
	pos, time)
{
	time = now()

	old = int(db["time"] / db["step"])
	new = int(time / db["step"])

	if (old > new)
		die("writing data in the past: old="old" new="new)
	if (length(val) != 1)
		die("invalid value '"val"' for "db["path"])

	db_set(db, "0", old, new)
	db_set(db, val, new - 1, new)
	db_time(db, time)
}

function line(file)
{
	while ((getline <file) > 0) {
		sub(/#.*/, "")
		if ($0 ~ /'/)
			die(file": single quote char")
		if ($0 ~ /[^ \t]/)
			return 1
	}
	return 0
}

function expand(str, var,
	key, val, res)
{
	while (match(str, /[$][A-Z_a-z_0-9]+/)) {
		key = substr(str, RSTART + 1, RLENGTH - 1)
		if (!(key in var))
			die("undefined variable $"key" in '"str"'")
		res = res substr(str, 1, RSTART - 1) var[key]
		str = substr(str, RSTART + RLENGTH)
	}
	return res str
}

function parse_variables(str, var,
	tok, i, key, val)
{
	split(str, tok, " ")
	str = ""
	for (i = 1; i in tok; i++) {
		key = val = tok[i]
		if (!sub(/=.*/, "", key) || !sub(/^[A-Z_a-z_0-9]+=/, "", val))
			die("invalid key=value declaration: '"tok[t]"'")
		var[key] = val
		str = str (str ? " " : "") key"='"val"'"
	}
	return str
}

function parse_entry(file, check, conf, name,
	loc, var, i, n, exec)
{
	if (!($1 0 in check))
		die(file": type '"$1"' not declared or type empty")

	# accumulate variables into a single string
	loc = $1"="$2
	for (i = 3; i <= NF; i++)
		loc = loc" "$i

	# check[] comes from parse_type called earlier
	for (i = 0; $1i in check; i++) {
		n = conf[""]++
		s = parse_variables(loc" "check[$1i], var)
		conf[n] = expand(s, var)" exec '"CHECK"/check-"var["check"]"'"
		name[n] = tolower($1"-"$2)
		gsub(/[^a-z0-9]+/, "-", name[n])
		sub(/-$/, "", name[n])
	}
}

function expect(file, got, wanted)
{
	if (got != wanted)
		die(file"#"type": expected '"wanted"' got '"got"'")
}

function parse_type(file, type, check,
	n, i)
{
	for (n = 0; line(file) && ($1 != "}"); n++) {
		expect(file, $1, "check")
		check[type n] = "check="$2
		for (i = 3; i <= NF; i++)
			check[type n] = check[type n]" "$i
	}
}

function parse(file, conf, name,
	type, check)
{
	while (line(file)) {
		if ($1 == "set") {
			conf[$2] = $3
		} else if ($1 == "type") {
			expect(file, $3, "{")
			parse_type(file, $2, check)
		} else {
			parse_entry(file, check, conf, name)
		}
	}
	if (!("step" in conf) || !("size" in conf))
		die("missing default 'step' or 'size' variables")
}

function show_conf(conf, name,
	i, last)
{
	print "step="conf["step"], "size="conf["size"]
	for (i = 1; i in conf; i++) {
		if (last != name[i])
			printf "\n[%s]\n", name[i]
		print conf[i]
		last = name[i]
	}
}

function show_graph(name, len,
	i, s, last, time, end)
{
	time = now()

	for (i = 0; ++i in name; last = name[i]) {
		if (last == name[i])
			continue
		printf "\n[%s]\n", name[i]
		db_open(db, DBDIR"/"name[i]".db")
		end = int(time / db["step"])
		s = db_get(db, end - len, end)
		gsub(/0/, " ", s); gsub(/1/, ":", s); gsub(/2/, "X", s)
		print s
		db_close(db)
	}
	printf "\n"
}

function init(conf, name,
	i)
{
	for (i = 0; i in conf; i++)
		db_init(DBDIR"/"name[i]".db", conf["step"], conf["size"])
}

function run(conf, name,
	i, e, val, path)
{
	for (i = 0; i in conf; i++) {
		if (name[i] != name[i-1])
			val[name[i]] = SUCCESS

		if (system(conf[i]" >/dev/null 2>&1") != 0) {
			print conf[i]
			val[name[i]] = FAILURE
		}

		if (name[i] != name[i+1]) {
			path = DBDIR"/"name[i]".db"
			if (system("exec test -f '"path"'") != 0)
				db_init(path, conf["step"], conf["size"])
			db_open(db, path)
			db_add(db, val[name[i]])
			db_close(db)
		}
	}
}

function usage()
{
	print "usage: monitower init"
	print "       monitower show conf"
	print "       monitower show graph"
	print "       monitower run"
	print "       monitower add <file> <value>"
	exit(1)
}

BEGIN {
	CHECK = ENVIRON["CHECK"] ? ENVIRON["CHECK"] : "/etc/monitower"
	DBDIR = ENVIRON["DBDIR"] ? ENVIRON["DBDIR"] : "/var/db/monitower"
	SUCCESS = 1; FAILURE = 2

	if (ARGV[1] == "init" && ARGC == 2) {
		parse("/etc/monitower.conf", conf, name)
		init(conf, name)

	} else if (ARGV[1] == "show" && ARGV[2] == "conf" && ARGC == 3) {
		parse("/etc/monitower.conf", conf, name)
		show_conf(conf, name)

	} else if (ARGV[1] == "show" && ARGV[2] == "graph" && ARGC == 3) {
		parse("/etc/monitower.conf", conf, name)
		show_graph(name, 80)

	} else if (ARGV[1] == "run" && ARGC == 2) {
		parse("/etc/monitower.conf", conf, name)
		run(conf, name)

	} else if (ARGV[1] == "add" && ARGC == 4) {
		db_open(db, ARGV[2])
		db_add(db, ARGV[3])
		db_close(db)

	} else {
		usage()
	}
}
