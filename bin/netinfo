#!/usr/bin/awk -f

function ip6_fe80(mac)
{
	mac = tolower(mac)
	gsub("[:-]", "", mac)
	return sprintf("fe80::%s:%s:%s:%s",
	  substr(mac, 1, 1) xor(substr(mac, 2, 1), 2) substr(mac, 3, 2),
	  substr(mac, 5, 2) "ff",
	  "fe" substr(mac, 7, 2),
	  substr(mac, 9, 2) substr(mac, 11, 2))
}

function ip6_hex(ip6,
	ar, out)
{
	sub("::", substr("::::::::", split(ip6, ar, ":") - 1), ip6)
	split(ip6, ar, ":")
	for (i = 1; i <= 8; i++)
		out = out substr("0000" ar[i], length(ar[i]) + 1)
	return out
}

function ip6_rev(ip6,
	out)
{
	ip6 = ip6_hex(ip6)
	for (i = 4 * 8; i > 0; i--)
		out = out substr(ip6, i, 1)"."
	return out"ip6.arpa"
}

function ip6_comp(ip6,
	beg, end, x)
{
	ip6 = ip6_hex(ip6)
	beg = substr(ip6, 1, 16);	end = substr(ip6, 17)
	x += sub("(0000)+$", "", beg);	x += sub("^(0000)+", "", end)
	gsub("....", ":&", beg);	gsub("....", ":&", end)
	gsub(":0*", ":", beg);		gsub(":0*", ":", end)
	return substr(beg, 2) (x ? ":" : "") end
}

function int_ip4(n)
{
	return (int(n/256^3) % 256)"."(int(n/256^2) % 256) \
	  "."(int(n/256^1) % 256)"."(int(n/256^0) % 256)
}

function ip4_int(ip4,
	ar, n)
{
	if (split(ip4, ar, ".") != 4) return
	return ar[1]*256^3 + ar[2]*256^2 + ar[3]*256^1 + ar[4]*256^0
}

function usage()
{
	print "usage:" >"/dev/stderr"
	print "	netinfo ip6-fe80 d0:32:45:21:45:22" >"/dev/stderr"
	print "	netinfo ip6-hex db8:134d:85fe:2054::1302:42" >"/dev/stderr"
	print "	netinfo ip6-rev db8:134d:85fe:2054::1302:42" >"/dev/stderr"
	print "	netinfo ip6-comp db8:134d:85fe:2054::1302:42" >"/dev/stderr"
	print "	netinfo int-ip4 65001" >"/dev/stderr"
	print "	netinfo ip4-int 65001" >"/dev/stderr"
	exit(1)
}

BEGIN {
	if (ARGC != 3) usage()
	else if (ARGV[1] == "ip6-fe80") print ip6_fe80(ARGV[2])
	else if (ARGV[1] == "ip6-hex") print ip6_hex(ARGV[2])
	else if (ARGV[1] == "ip6-rev") print ip6_rev(ARGV[2])
	else if (ARGV[1] == "ip6-comp") print ip6_comp(ARGV[2])
	else if (ARGV[1] == "int-ip4") print int_ip4(ARGV[2])
	else if (ARGV[1] == "ip4-int") print ip4_int(ARGV[2])
	else usage()
}
